#include <iostream> // Подключение библиотеки ввода-вывода для работы с консолью
#include <vector>   // Подключение контейнера vector (динамический массив)
#include <algorithm> // Подключение библиотеки алгоритмов (например, для функции swap)
#include <chrono>   // Подключение библиотеки для измерения времени выполнения кода
#include <cstdlib>  // Подключение стандартной библиотеки (rand, srand)
#include <omp.h>    // Подключение библиотеки OpenMP для многопоточности

using namespace std; // Использование стандартного пространства имен std
using namespace std::chrono; // Использование пространства имен chrono для таймеров

// --- SEQUENTIAL SORTS (Последовательные сортировки) ---

// Функция сортировки пузырьком (Bubble Sort) - последовательная версия
void bubbleSort(vector<int>& arr) {
    int n = arr.size(); // Получаем размер массива
    // Внешний цикл прохода по массиву
    for (int i = 0; i < n - 1; ++i) {
        // Внутренний цикл для сравнения соседних элементов
        // С каждым проходом диапазон уменьшается на i, так как самые большие элементы всплывают в конец
        for (int j = 0; j < n - i - 1; ++j) {
            // Если текущий элемент больше следующего
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]); // Меняем их местами
            }
        }
    }
}

// Функция сортировки выбором (Selection Sort) - последовательная версия
void selectionSort(vector<int>& arr) {
    int n = arr.size(); // Получаем размер массива
    // Проходим по каждому элементу массива
    for (int i = 0; i < n - 1; ++i) {
        int min_idx = i; // Предполагаем, что текущий элемент - минимальный
        // Ищем реальный минимальный элемент в оставшейся части массива
        for (int j = i + 1; j < n; ++j) {
            // Если нашли элемент меньше текущего минимума
            if (arr[j] < arr[min_idx]) {
                min_idx = j; // Запоминаем его индекс
            }
        }
        swap(arr[min_idx], arr[i]); // Меняем местами найденный минимум с текущим элементом i
    }
}

// Функция сортировки вставкой (Insertion Sort) - последовательная версия
void insertionSort(vector<int>& arr) {
    int n = arr.size(); // Получаем размер массива
    // Начинаем со второго элемента (индекс 1)
    for (int i = 1; i < n; ++i) {
        int key = arr[i]; // Запоминаем текущий элемент, который нужно вставить
        int j = i - 1; // Индекс предыдущего элемента
        
        // Сдвигаем элементы, которые больше key, на одну позицию вправо
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j]; // Перемещаем элемент вправо
            j = j - 1; // Сдвигаемся влево для проверки следующего
        }
        arr[j + 1] = key; // Вставляем key на освободившееся место
    }
}

// --- PARALLEL SORTS (Параллельные сортировки с OpenMP) ---

// Параллельная сортировка пузырьком (Четно-нечетная перестановка)
// Классический пузырек плохо параллелится, поэтому используем алгоритм Odd-Even Transposition Sort
void parallelBubbleSort(vector<int>& arr) {
    int n = arr.size(); // Получаем размер массива
    bool sorted = false; // Флаг отсортированности массива
    
    // Цикл до тех пор, пока массив не будет отсортирован или пока не пройдем n раз
    for (int i = 0; i < n; ++i) { 
        sorted = true; // Сбрасываем флаг (предполагаем, что отсортирован)
        
        // Нечетная фаза (Odd phase)
        // #pragma omp parallel for - распараллеливаем цикл for между потоками
        #pragma omp parallel for
        for (int j = 1; j < n - 1; j += 2) {
            // Сравниваем пары элементов с нечетными индексами (1-2, 3-4...)
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]); // Меняем местами если порядок неверный
                sorted = false; // Значит массив еще не полностью отсортирован
            }
        }
        
        // Четная фаза (Even phase)
        // Также распараллеливаем этот цикл
        #pragma omp parallel for
        for (int j = 0; j < n - 1; j += 2) {
            // Сравниваем пары элементов с четными индексами (0-1, 2-3...)
            if (arr[j] > arr[j + 1]) {
                 swap(arr[j], arr[j + 1]); // Меняем местами
                 sorted = false; // Был обмен
            }
        }
        // Здесь можно добавить 'break', если sorted остался true, но для стабильности на GPU/Parallel часто пропускают
    }
}

// Параллельная сортировка выбором (Parallel Selection Sort)
// Мы параллелим процесс поиска минимального элемента
void parallelSelectionSort(vector<int>& arr) {
    int n = arr.size(); // Получаем размер
    // Внешний цикл последователен, так как мы расставляем элементы по порядку
    for (int i = 0; i < n - 1; ++i) {
        
        int min_idx = i; // Индекс минимума
        int min_val = arr[i]; // Значение минимума
         
         // Начало параллельной области (создается группа потоков)
         #pragma omp parallel
         {
             int local_min_idx = min_idx; // Локальный индекс минимума для каждого потока
             int local_min_val = min_val; // Локальное значение минимума
             
             // #pragma omp for nowait - распределяем итерации цикла между потоками
             // nowait убирает барьер синхронизации в конце, так как дальше идет критическая секция
             for (int j = i + 1; j < n; ++j) {
                 // Каждый поток ищет минимум в своем диапазоне данных
                 if (arr[j] < local_min_val) {
                     local_min_val = arr[j]; // Обновляем локальный минимум
                     local_min_idx = j;      // Обновляем локальный индекс
                 }
             }
             
             // Критическая секция: выполняется только одним потоком единовременно
             // Здесь мы объединяем результаты всех потоков
             #pragma omp critical
             {
                 // Сравниваем локальный минимум потока с глобальным минимумом
                 if (local_min_val < min_val) {
                     min_val = local_min_val; // Обновляем глобальное значение минимума
                     min_idx = local_min_idx; // Обновляем глобальный индекс
                 }
             }
         }
         // Меняем найденный глобальный минимум с текущим элементом i
         swap(arr[i], arr[min_idx]);
    }
}

// Параллельная сортировка вставкой (Parallel Insertion Sort)
// Примечание: Сортировка вставкой очень тяжело распараллеливается эффективно,
// так как каждый следующий шаг зависит от предыдущего состояния массива.
// Поэтому здесь использована последовательная версия.
void parallelInsertionSort(vector<int>& arr) {
    // В учебных целях просто вызываем последовательную версию,
    // так как "честная" параллельная вставка сложнее и обычно неэффективна
    insertionSort(arr); 
}

// --- Утилиты (Вспомогательные функции) ---

// Функция для проверки, отсортирован ли массив
void checkSorted(const vector<int>& arr, const string& name) {
    bool sorted = true;
    for (size_t i = 0; i < arr.size() - 1; ++i) {
        if (arr[i] > arr[i + 1]) {
            sorted = false;
            break;
        }
    }
    // Здесь можно включить вывод, если нужно: cout << name << ": " << (sorted ? "OK" : "FAIL") << endl;
}

// Функция для измерения времени выполнения сортировки
// Принимает указатель на функцию сортировки, массив (копия) и имя алгоритма
void measure(void (*sortFunc)(vector<int>&), vector<int> arr, const string& name) {
    // Засекаем время начала
    auto start = high_resolution_clock::now();
    sortFunc(arr); // Запускаем сортировку
    // Засекаем время окончания
    auto stop = high_resolution_clock::now();
    
    // Вычисляем продолжительность в миллисекундах
    auto duration = duration_cast<milliseconds>(stop - start);
    
    checkSorted(arr, name); // Проверяем корректность (для отладки)
    // Выводим имя алгоритма и время работы
    cout << name << ": " << duration.count() << " ms" << endl;
}

int main() {
    // Вектор с размерами массивов для тестов
    // 1000 - маленький, 10000 - средний, 30000 - большой (но разумный для ожидания)
    vector<int> sizes = {1000, 10000, 30000}; 

    // Инициализация рандома текущим временем
    srand(time(0));

    // Цикл по всем размерам массивов
    for (int n : sizes) {
        cout << "\n--- Array Size (Размер массива): " << n << " ---" << endl;
        
        // Создаем массив указанного размера
        vector<int> data(n);
        for (int i = 0; i < n; ++i) {
            data[i] = rand() % 100000; // Заполняем случайными числами
        }

        // Запуск последовательных сортировок (передаем копии массива data)
        measure(bubbleSort, data, "Sequential Bubble Sort (Послед. Пузырек)");
        measure(selectionSort, data, "Sequential Selection Sort (Послед. Выбор)");
        measure(insertionSort, data, "Sequential Insertion Sort (Послед. Вставка)");

        // Запуск параллельных сортировок
        measure(parallelBubbleSort, data, "Parallel Bubble Sort (Парал. Пузырек)");
        measure(parallelSelectionSort, data, "Parallel Selection Sort (Парал. Выбор)");
        measure(parallelInsertionSort, data, "Parallel Insertion Sort (Парал. Вставка - обертка)");
    }

    return 0; // Завершение программы
}
